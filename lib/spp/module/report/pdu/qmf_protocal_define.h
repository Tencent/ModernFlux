// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.0.0.31 by WSRD Tencent.
// Generated from `/usr/local/resin_system.mqq.com/webapps/communication/taf/upload/evanqi/qmf_protocal_define.jce'
// **********************************************************************

#ifndef __QMF_PROTOCAL_DEFINE_H_
#define __QMF_PROTOCAL_DEFINE_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
#include "pdu_header.h"
using namespace std;


struct pdu_protocol_header;

namespace QMF_PROTOCAL
{
    const taf::Int32 ENUM_TOKEN_TYPE_NULL = 0;

    const taf::Int32 ENUM_TOKEN_TYPE_WEB = 1;

    const taf::Int32 ENUM_TOKEN_TYPE_SVR = 2;

    const taf::Int32 ENUM_TOKEN_TYPE_LSKEY = 4;

    const taf::Int32 ENUM_TOKEN_TYPE_A8 = 32;

    const taf::Int32 ENUM_TOKEN_TYPE_A2 = 64;

    const taf::Int32 ENUM_TOKEN_TYPE_SID = 128;

    const taf::Int32 ENUM_TOKEN_TYPE_REFRESHTOKEN_WEIXIN = 192;

    const taf::Int32 ENUM_TOKEN_TYPE_REFRESHTOKEN_QQ = 224;

    const std::string KEY_EXTRA_ACCINFO = "accinfo";

    const std::string KEY_EXTRA_ACCWANIP = "acc_wanip";

    const std::string KEY_EXTRA_ACCWANPORT = "acc_wanport";

    const std::string KEY_EXTRA_BUSICOMPCONTROL = "busiCompCtl";

    const std::string KEY_EXTRA_CONF_REQ = "conf_info_req";

    const std::string KEY_EXTRA_CONF_RSP = "conf_info_rsp";

    const std::string KEY_EXTRA_BIN_A2_KEY = "bin_a2_key";

    const std::string KEY_EXTRA_BIGPIPLE = "bigpiple";

    const std::string KEY_EXTRA_IPCRED_DOMAIN = "cmd_ipcred_domain";

    const std::string KEY_EXTRA_SDK_VERSION = "wns_sdk_version";

    const std::string KEY_EXTRA_CONF_RSP_LEN = "conf_info_rsp_len";

    const std::string KEY_EXTRA_APP_DOWNLOAD = "app_dl_url";

    const std::string KEY_EXTRA_CLOG = "clog";

    const std::string KEY_DEVICEINFO_OS = "os";

    const std::string KEY_DEVICEINFO_MODEL = "model";

    const std::string KEY_EXTRA_PUSH_POSI = "position";

    const taf::Int32 ENUM_TOKEN_MAP_OPENID_KEY = 1;

    enum eGetConfigScene
    {
        SceneAppRun,
        SceneAppActivate,
        SceneTimeout,
        SceneNetworkChanged,
        SQGetConfigAppStart = 100,
        SQGetConfigApnChanged,
        SQGetConfigAppTimer,
        SQGetConfigFromBackToFront,
    };
    inline string etos(const eGetConfigScene & e)
    {
        switch(e)
        {
            case SceneAppRun: return "SceneAppRun";
            case SceneAppActivate: return "SceneAppActivate";
            case SceneTimeout: return "SceneTimeout";
            case SceneNetworkChanged: return "SceneNetworkChanged";
            case SQGetConfigAppStart: return "SQGetConfigAppStart";
            case SQGetConfigApnChanged: return "SQGetConfigApnChanged";
            case SQGetConfigAppTimer: return "SQGetConfigAppTimer";
            case SQGetConfigFromBackToFront: return "SQGetConfigFromBackToFront";
            default: return "";
        }
    }
    inline int stoe(const string & s, eGetConfigScene & e)
    {
        if(s == "SceneAppRun")  { e=SceneAppRun; return 0;}
        if(s == "SceneAppActivate")  { e=SceneAppActivate; return 0;}
        if(s == "SceneTimeout")  { e=SceneTimeout; return 0;}
        if(s == "SceneNetworkChanged")  { e=SceneNetworkChanged; return 0;}
        if(s == "SQGetConfigAppStart")  { e=SQGetConfigAppStart; return 0;}
        if(s == "SQGetConfigApnChanged")  { e=SQGetConfigApnChanged; return 0;}
        if(s == "SQGetConfigAppTimer")  { e=SQGetConfigAppTimer; return 0;}
        if(s == "SQGetConfigFromBackToFront")  { e=SQGetConfigFromBackToFront; return 0;}

        return -1;
    }

    struct QmfClientIpInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.QmfClientIpInfo";
        }
        static string MD5()
        {
            return "b261295e8c4acff31eb780534c412ced";
        }
        QmfClientIpInfo()
        :IpType(0),ClientPort(0),ClientIpv4(0),ClientIpv6Len(0)
        {
            memset(ClientIpv6, 0, sizeof(ClientIpv6));
        }
        void resetDefautlt()
        {
            IpType = 0;
            ClientPort = 0;
            ClientIpv4 = 0;
            ClientIpv6Len = 0;
            memset(ClientIpv6, 0, sizeof(ClientIpv6));
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(IpType, 0);
            _os.write(ClientPort, 1);
            _os.write(ClientIpv4, 2);
            _os.write((const taf::Char *)ClientIpv6, ClientIpv6Len, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(IpType, 0, true);
            _is.read(ClientPort, 1, true);
            _is.read(ClientIpv4, 2, true);
            _is.read(ClientIpv6, 16, ClientIpv6Len, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(IpType,"IpType");
            _ds.display(ClientPort,"ClientPort");
            _ds.display(ClientIpv4,"ClientIpv4");
            _ds.display(ClientIpv6, ClientIpv6Len,"ClientIpv6");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(IpType, true);
            _ds.displaySimple(ClientPort, true);
            _ds.displaySimple(ClientIpv4, true);
            _ds.displaySimple(ClientIpv6, ClientIpv6Len,false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Char IpType;
        taf::Short ClientPort;
        taf::Int32 ClientIpv4;
        taf::UInt32 ClientIpv6Len;
        taf::Char ClientIpv6[16];
    };
    inline bool operator==(const QmfClientIpInfo&l, const QmfClientIpInfo&r)
    {
        return l.IpType == r.IpType && l.ClientPort == r.ClientPort && l.ClientIpv4 == r.ClientIpv4 && !memcmp(l.ClientIpv6,r.ClientIpv6,l.ClientIpv6Len);
    }
    inline bool operator!=(const QmfClientIpInfo&l, const QmfClientIpInfo&r)
    {
        return !(l == r);
    }
    int struct_QmfClientIpInfo_pack(QmfClientIpInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_QmfClientIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfClientIpInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_QmfClientIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfClientIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct QmfTokenInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.QmfTokenInfo";
        }
        static string MD5()
        {
            return "76f7ca738f131aab5fc911dd09e04b21";
        }
        QmfTokenInfo()
        :Type(0)
        {
        }
        void resetDefautlt()
        {
            Type = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(Type, 0);
            _os.write(Key, 1);
            _os.write(ext_key, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(Type, 0, true);
            _is.read(Key, 1, true);
            _is.read(ext_key, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(Type,"Type");
            _ds.display(Key,"Key");
            _ds.display(ext_key,"ext_key");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(Type, true);
            _ds.displaySimple(Key, true);
            _ds.displaySimple(ext_key, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 Type;
        vector<taf::Char> Key;
        map<taf::Int32, vector<taf::Char> > ext_key;
    };
    inline bool operator==(const QmfTokenInfo&l, const QmfTokenInfo&r)
    {
        return l.Type == r.Type && l.Key == r.Key && l.ext_key == r.ext_key;
    }
    inline bool operator!=(const QmfTokenInfo&l, const QmfTokenInfo&r)
    {
        return !(l == r);
    }
    int struct_QmfTokenInfo_pack(QmfTokenInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_QmfTokenInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfTokenInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_QmfTokenInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfTokenInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct QmfAccInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.QmfAccInfo";
        }
        static string MD5()
        {
            return "80a4a82e816e743204d3ec593e761546";
        }
        QmfAccInfo()
        :AccId(0),AccIp(0),AccPort(0),AccFlag(0)
        {
        }
        void resetDefautlt()
        {
            AccId = 0;
            AccIp = 0;
            AccPort = 0;
            AccFlag = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(AccId, 0);
            _os.write(AccIp, 1);
            _os.write(AccPort, 2);
            _os.write(AccFlag, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(AccId, 0, true);
            _is.read(AccIp, 1, true);
            _is.read(AccPort, 2, true);
            _is.read(AccFlag, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(AccId,"AccId");
            _ds.display(AccIp,"AccIp");
            _ds.display(AccPort,"AccPort");
            _ds.display(AccFlag,"AccFlag");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(AccId, true);
            _ds.displaySimple(AccIp, true);
            _ds.displaySimple(AccPort, true);
            _ds.displaySimple(AccFlag, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int64 AccId;
        taf::Int32 AccIp;
        taf::Short AccPort;
        taf::Char AccFlag;
    };
    inline bool operator==(const QmfAccInfo&l, const QmfAccInfo&r)
    {
        return l.AccId == r.AccId && l.AccIp == r.AccIp && l.AccPort == r.AccPort && l.AccFlag == r.AccFlag;
    }
    inline bool operator!=(const QmfAccInfo&l, const QmfAccInfo&r)
    {
        return !(l == r);
    }
    int struct_QmfAccInfo_pack(QmfAccInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_QmfAccInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfAccInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_QmfAccInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfAccInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct QmfBusiControl : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.QmfBusiControl";
        }
        static string MD5()
        {
            return "d56c7d58ecb3a90fe219a50e5011610c";
        }
        QmfBusiControl()
        :compFlag(0),lenBeforeComp(0),rspCompFlag(0),noexit(true)
        {
        }
        void resetDefautlt()
        {
            compFlag = 0;
            lenBeforeComp = 0;
            rspCompFlag = 0;
            noexit = true;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(compFlag, 0);
            _os.write(lenBeforeComp, 1);
            _os.write(rspCompFlag, 2);
            _os.write(noexit, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(compFlag, 0, true);
            _is.read(lenBeforeComp, 1, true);
            _is.read(rspCompFlag, 2, true);
            _is.read(noexit, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(compFlag,"compFlag");
            _ds.display(lenBeforeComp,"lenBeforeComp");
            _ds.display(rspCompFlag,"rspCompFlag");
            _ds.display(noexit,"noexit");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(compFlag, true);
            _ds.displaySimple(lenBeforeComp, true);
            _ds.displaySimple(rspCompFlag, true);
            _ds.displaySimple(noexit, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 compFlag;
        taf::Int64 lenBeforeComp;
        taf::Int32 rspCompFlag;
        taf::Bool noexit;
    };
    inline bool operator==(const QmfBusiControl&l, const QmfBusiControl&r)
    {
        return l.compFlag == r.compFlag && l.lenBeforeComp == r.lenBeforeComp && l.rspCompFlag == r.rspCompFlag && l.noexit == r.noexit;
    }
    inline bool operator!=(const QmfBusiControl&l, const QmfBusiControl&r)
    {
        return !(l == r);
    }
    int struct_QmfBusiControl_pack(QmfBusiControl * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_QmfBusiControl_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfBusiControl * pst_struct, pdu_protocol_header * pdu_header);
    int struct_QmfBusiControl_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfBusiControl * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct mobile_get_config_req : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.mobile_get_config_req";
        }
        static string MD5()
        {
            return "72dfddf03422779b81fb661a3938fb92";
        }
        mobile_get_config_req()
        :appid(0),scene(0),cookies("")
        {
        }
        void resetDefautlt()
        {
            appid = 0;
            scene = 0;
            cookies = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(appid, 0);
            _os.write(scene, 1);
            _os.write(cookies, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(appid, 0, false);
            _is.read(scene, 1, false);
            _is.read(cookies, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(appid,"appid");
            _ds.display(scene,"scene");
            _ds.display(cookies,"cookies");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(appid, true);
            _ds.displaySimple(scene, true);
            _ds.displaySimple(cookies, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 appid;
        taf::Int32 scene;
        std::string cookies;
    };
    inline bool operator==(const mobile_get_config_req&l, const mobile_get_config_req&r)
    {
        return l.appid == r.appid && l.scene == r.scene && l.cookies == r.cookies;
    }
    inline bool operator!=(const mobile_get_config_req&l, const mobile_get_config_req&r)
    {
        return !(l == r);
    }
    int struct_mobile_get_config_req_pack(mobile_get_config_req * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_mobile_get_config_req_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, mobile_get_config_req * pst_struct, pdu_protocol_header * pdu_header);
    int struct_mobile_get_config_req_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, mobile_get_config_req * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct mobile_get_config_rsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.mobile_get_config_rsp";
        }
        static string MD5()
        {
            return "31cbbb2b7248e13d386cffdf8c500472";
        }
        mobile_get_config_rsp()
        :cookies(""),scene_flag(0)
        {
        }
        void resetDefautlt()
        {
            cookies = "";
            scene_flag = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(config, 0);
            _os.write(cookies, 1);
            _os.write(scene_flag, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(config, 0, false);
            _is.read(cookies, 1, false);
            _is.read(scene_flag, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(config,"config");
            _ds.display(cookies,"cookies");
            _ds.display(scene_flag,"scene_flag");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(config, true);
            _ds.displaySimple(cookies, true);
            _ds.displaySimple(scene_flag, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        map<std::string, vector<taf::Char> > config;
        std::string cookies;
        taf::Int32 scene_flag;
    };
    inline bool operator==(const mobile_get_config_rsp&l, const mobile_get_config_rsp&r)
    {
        return l.config == r.config && l.cookies == r.cookies && l.scene_flag == r.scene_flag;
    }
    inline bool operator!=(const mobile_get_config_rsp&l, const mobile_get_config_rsp&r)
    {
        return !(l == r);
    }
    int struct_mobile_get_config_rsp_pack(mobile_get_config_rsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_mobile_get_config_rsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, mobile_get_config_rsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_mobile_get_config_rsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, mobile_get_config_rsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct RetryInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.RetryInfo";
        }
        static string MD5()
        {
            return "51f6184f17b7f96408fe779c4a8f02b0";
        }
        RetryInfo()
        :Flag(0),RetryCount(0),PkgId(0)
        {
        }
        void resetDefautlt()
        {
            Flag = 0;
            RetryCount = 0;
            PkgId = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(Flag, 0);
            _os.write(RetryCount, 1);
            _os.write(PkgId, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(Flag, 0, true);
            _is.read(RetryCount, 1, true);
            _is.read(PkgId, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(Flag,"Flag");
            _ds.display(RetryCount,"RetryCount");
            _ds.display(PkgId,"PkgId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(Flag, true);
            _ds.displaySimple(RetryCount, true);
            _ds.displaySimple(PkgId, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt8 Flag;
        taf::UInt16 RetryCount;
        taf::Int64 PkgId;
    };
    inline bool operator==(const RetryInfo&l, const RetryInfo&r)
    {
        return l.Flag == r.Flag && l.RetryCount == r.RetryCount && l.PkgId == r.PkgId;
    }
    inline bool operator!=(const RetryInfo&l, const RetryInfo&r)
    {
        return !(l == r);
    }
    int struct_RetryInfo_pack(RetryInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_RetryInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, RetryInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_RetryInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, RetryInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct QmfUpstream : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.QmfUpstream";
        }
        static string MD5()
        {
            return "538b9f5697e991abe09f7d0d095a7bb9";
        }
        QmfUpstream()
        :Seq(0),Appid(0),Uin(0),Qua(""),ServiceCmd(""),DeviceInfo(""),flag(0),sessionID(0),uid("")
        {
        }
        void resetDefautlt()
        {
            Seq = 0;
            Appid = 0;
            Uin = 0;
            Qua = "";
            ServiceCmd = "";
            DeviceInfo = "";
            flag = 0;
            sessionID = 0;
            uid = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(Seq, 0);
            _os.write(Appid, 1);
            _os.write(Uin, 2);
            _os.write(Qua, 3);
            _os.write(ServiceCmd, 4);
            _os.write(DeviceInfo, 5);
            _os.write(Token, 6);
            _os.write(IpInfo, 7);
            _os.write(BusiBuff, 8);
            _os.write(Extra, 9);
            _os.write(flag, 10);
            _os.write(sessionID, 11);
            _os.write(retryinfo, 12);
            _os.write(BusiControl, 13);
            _os.write(uid, 14);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(Seq, 0, true);
            _is.read(Appid, 1, true);
            _is.read(Uin, 2, true);
            _is.read(Qua, 3, true);
            _is.read(ServiceCmd, 4, true);
            _is.read(DeviceInfo, 5, true);
            _is.read(Token, 6, true);
            _is.read(IpInfo, 7, true);
            _is.read(BusiBuff, 8, true);
            _is.read(Extra, 9, true);
            _is.read(flag, 10, false);
            _is.read(sessionID, 11, false);
            _is.read(retryinfo, 12, false);
            _is.read(BusiControl, 13, false);
            _is.read(uid, 14, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(Seq,"Seq");
            _ds.display(Appid,"Appid");
            _ds.display(Uin,"Uin");
            _ds.display(Qua,"Qua");
            _ds.display(ServiceCmd,"ServiceCmd");
            _ds.display(DeviceInfo,"DeviceInfo");
            _ds.display(Token,"Token");
            _ds.display(IpInfo,"IpInfo");
            _ds.display(BusiBuff,"BusiBuff");
            _ds.display(Extra,"Extra");
            _ds.display(flag,"flag");
            _ds.display(sessionID,"sessionID");
            _ds.display(retryinfo,"retryinfo");
            _ds.display(BusiControl,"BusiControl");
            _ds.display(uid,"uid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(Seq, true);
            _ds.displaySimple(Appid, true);
            _ds.displaySimple(Uin, true);
            _ds.displaySimple(Qua, true);
            _ds.displaySimple(ServiceCmd, true);
            _ds.displaySimple(DeviceInfo, true);
            _ds.displaySimple(Token, true);
            _ds.displaySimple(IpInfo, true);
            _ds.displaySimple(BusiBuff, true);
            _ds.displaySimple(Extra, true);
            _ds.displaySimple(flag, true);
            _ds.displaySimple(sessionID, true);
            _ds.displaySimple(retryinfo, true);
            _ds.displaySimple(BusiControl, true);
            _ds.displaySimple(uid, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 Seq;
        taf::Int32 Appid;
        taf::Int64 Uin;
        std::string Qua;
        std::string ServiceCmd;
        std::string DeviceInfo;
        QMF_PROTOCAL::QmfTokenInfo Token;
        QMF_PROTOCAL::QmfClientIpInfo IpInfo;
        vector<taf::Char> BusiBuff;
        vector<taf::Char> Extra;
        taf::UInt32 flag;
        taf::UInt32 sessionID;
        QMF_PROTOCAL::RetryInfo retryinfo;
        QMF_PROTOCAL::QmfBusiControl BusiControl;
        std::string uid;
    };
    inline bool operator==(const QmfUpstream&l, const QmfUpstream&r)
    {
        return l.Seq == r.Seq && l.Appid == r.Appid && l.Uin == r.Uin && l.Qua == r.Qua && l.ServiceCmd == r.ServiceCmd && l.DeviceInfo == r.DeviceInfo && l.Token == r.Token && l.IpInfo == r.IpInfo && l.BusiBuff == r.BusiBuff && l.Extra == r.Extra && l.flag == r.flag && l.sessionID == r.sessionID && l.retryinfo == r.retryinfo && l.BusiControl == r.BusiControl && l.uid == r.uid;
    }
    inline bool operator!=(const QmfUpstream&l, const QmfUpstream&r)
    {
        return !(l == r);
    }
    int struct_QmfUpstream_pack(QmfUpstream * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_QmfUpstream_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfUpstream * pst_struct, pdu_protocol_header * pdu_header);
    int struct_QmfUpstream_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfUpstream * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct QmfDownstream : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.QmfDownstream";
        }
        static string MD5()
        {
            return "632c5d8d0fda120814bb2e4aba148166";
        }
        QmfDownstream()
        :Seq(0),Uin(0),WnsCode(0),BizCode(0),ServiceCmd(""),WnsErrorMsg(""),uid("")
        {
        }
        void resetDefautlt()
        {
            Seq = 0;
            Uin = 0;
            WnsCode = 0;
            BizCode = 0;
            ServiceCmd = "";
            WnsErrorMsg = "";
            uid = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(Seq, 0);
            _os.write(Uin, 1);
            _os.write(WnsCode, 2);
            _os.write(BizCode, 3);
            _os.write(ServiceCmd, 4);
            _os.write(BusiBuff, 5);
            _os.write(Extra, 6);
            _os.write(WnsErrorMsg, 7);
            _os.write(uid, 8);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(Seq, 0, true);
            _is.read(Uin, 1, true);
            _is.read(WnsCode, 2, true);
            _is.read(BizCode, 3, true);
            _is.read(ServiceCmd, 4, true);
            _is.read(BusiBuff, 5, true);
            _is.read(Extra, 6, true);
            _is.read(WnsErrorMsg, 7, false);
            _is.read(uid, 8, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(Seq,"Seq");
            _ds.display(Uin,"Uin");
            _ds.display(WnsCode,"WnsCode");
            _ds.display(BizCode,"BizCode");
            _ds.display(ServiceCmd,"ServiceCmd");
            _ds.display(BusiBuff,"BusiBuff");
            _ds.display(Extra,"Extra");
            _ds.display(WnsErrorMsg,"WnsErrorMsg");
            _ds.display(uid,"uid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(Seq, true);
            _ds.displaySimple(Uin, true);
            _ds.displaySimple(WnsCode, true);
            _ds.displaySimple(BizCode, true);
            _ds.displaySimple(ServiceCmd, true);
            _ds.displaySimple(BusiBuff, true);
            _ds.displaySimple(Extra, true);
            _ds.displaySimple(WnsErrorMsg, true);
            _ds.displaySimple(uid, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 Seq;
        taf::Int64 Uin;
        taf::Short WnsCode;
        taf::Short BizCode;
        std::string ServiceCmd;
        vector<taf::Char> BusiBuff;
        vector<taf::Char> Extra;
        std::string WnsErrorMsg;
        std::string uid;
    };
    inline bool operator==(const QmfDownstream&l, const QmfDownstream&r)
    {
        return l.Seq == r.Seq && l.Uin == r.Uin && l.WnsCode == r.WnsCode && l.BizCode == r.BizCode && l.ServiceCmd == r.ServiceCmd && l.BusiBuff == r.BusiBuff && l.Extra == r.Extra && l.WnsErrorMsg == r.WnsErrorMsg && l.uid == r.uid;
    }
    inline bool operator!=(const QmfDownstream&l, const QmfDownstream&r)
    {
        return !(l == r);
    }
    int struct_QmfDownstream_pack(QmfDownstream * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_QmfDownstream_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfDownstream * pst_struct, pdu_protocol_header * pdu_header);
    int struct_QmfDownstream_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfDownstream * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct ServiceOverLoad : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.ServiceOverLoad";
        }
        static string MD5()
        {
            return "5776fd7103fcea055637c7e8b9708bb0";
        }
        ServiceOverLoad()
        :limitedTime(0),Msg(""),appid(-1)
        {
        }
        void resetDefautlt()
        {
            limitedTime = 0;
            Msg = "";
            appid = -1;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(limitedTime, 0);
            _os.write(Msg, 1);
            _os.write(appid, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(limitedTime, 0, true);
            _is.read(Msg, 1, true);
            _is.read(appid, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(limitedTime,"limitedTime");
            _ds.display(Msg,"Msg");
            _ds.display(appid,"appid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(limitedTime, true);
            _ds.displaySimple(Msg, true);
            _ds.displaySimple(appid, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 limitedTime;
        std::string Msg;
        taf::Int32 appid;
    };
    inline bool operator==(const ServiceOverLoad&l, const ServiceOverLoad&r)
    {
        return l.limitedTime == r.limitedTime && l.Msg == r.Msg && l.appid == r.appid;
    }
    inline bool operator!=(const ServiceOverLoad&l, const ServiceOverLoad&r)
    {
        return !(l == r);
    }
    int struct_ServiceOverLoad_pack(ServiceOverLoad * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_ServiceOverLoad_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ServiceOverLoad * pst_struct, pdu_protocol_header * pdu_header);
    int struct_ServiceOverLoad_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ServiceOverLoad * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCommonStringMap : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.WnsCommonStringMap";
        }
        static string MD5()
        {
            return "6f9bbe5ace26b7b7f6916c52b00462f6";
        }
        WnsCommonStringMap()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(data, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(data, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(data,"data");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(data, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        map<std::string, std::string> data;
    };
    inline bool operator==(const WnsCommonStringMap&l, const WnsCommonStringMap&r)
    {
        return l.data == r.data;
    }
    inline bool operator!=(const WnsCommonStringMap&l, const WnsCommonStringMap&r)
    {
        return !(l == r);
    }
    int struct_WnsCommonStringMap_pack(WnsCommonStringMap * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCommonStringMap_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCommonStringMap * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCommonStringMap_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCommonStringMap * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCommonBufferMap : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.WnsCommonBufferMap";
        }
        static string MD5()
        {
            return "fbee9257f7e9e33c4d6a504ff54a1f48";
        }
        WnsCommonBufferMap()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(data, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(data, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(data,"data");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(data, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        map<std::string, vector<taf::Char> > data;
    };
    inline bool operator==(const WnsCommonBufferMap&l, const WnsCommonBufferMap&r)
    {
        return l.data == r.data;
    }
    inline bool operator!=(const WnsCommonBufferMap&l, const WnsCommonBufferMap&r)
    {
        return !(l == r);
    }
    int struct_WnsCommonBufferMap_pack(WnsCommonBufferMap * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCommonBufferMap_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCommonBufferMap * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCommonBufferMap_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCommonBufferMap * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct QmfProvidorReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_PROTOCAL.QmfProvidorReq";
        }
        static string MD5()
        {
            return "012360485e597e62bbe024129436210c";
        }
        QmfProvidorReq()
        :SeqNo(0),Uin(0),Appid(0),ServiceCmd(""),Time(0),Version(0),DeviceToken("")
        {
        }
        void resetDefautlt()
        {
            SeqNo = 0;
            Uin = 0;
            Appid = 0;
            ServiceCmd = "";
            Time = 0;
            Version = 0;
            DeviceToken = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(SeqNo, 0);
            _os.write(Uin, 1);
            _os.write(Appid, 2);
            _os.write(ServiceCmd, 3);
            _os.write(Time, 4);
            _os.write(Version, 5);
            _os.write(Data, 6);
            _os.write(DeviceToken, 7);
            _os.write(Reserve, 8);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(SeqNo, 0, true);
            _is.read(Uin, 1, true);
            _is.read(Appid, 2, true);
            _is.read(ServiceCmd, 3, true);
            _is.read(Time, 4, true);
            _is.read(Version, 5, true);
            _is.read(Data, 6, true);
            _is.read(DeviceToken, 7, false);
            _is.read(Reserve, 8, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(SeqNo,"SeqNo");
            _ds.display(Uin,"Uin");
            _ds.display(Appid,"Appid");
            _ds.display(ServiceCmd,"ServiceCmd");
            _ds.display(Time,"Time");
            _ds.display(Version,"Version");
            _ds.display(Data,"Data");
            _ds.display(DeviceToken,"DeviceToken");
            _ds.display(Reserve,"Reserve");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(SeqNo, true);
            _ds.displaySimple(Uin, true);
            _ds.displaySimple(Appid, true);
            _ds.displaySimple(ServiceCmd, true);
            _ds.displaySimple(Time, true);
            _ds.displaySimple(Version, true);
            _ds.displaySimple(Data, true);
            _ds.displaySimple(DeviceToken, true);
            _ds.displaySimple(Reserve, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 SeqNo;
        taf::UInt32 Uin;
        taf::Int32 Appid;
        std::string ServiceCmd;
        taf::UInt32 Time;
        taf::Int32 Version;
        vector<taf::Char> Data;
        std::string DeviceToken;
        map<std::string, std::string> Reserve;
    };
    inline bool operator==(const QmfProvidorReq&l, const QmfProvidorReq&r)
    {
        return l.SeqNo == r.SeqNo && l.Uin == r.Uin && l.Appid == r.Appid && l.ServiceCmd == r.ServiceCmd && l.Time == r.Time && l.Version == r.Version && l.Data == r.Data && l.DeviceToken == r.DeviceToken && l.Reserve == r.Reserve;
    }
    inline bool operator!=(const QmfProvidorReq&l, const QmfProvidorReq&r)
    {
        return !(l == r);
    }
    int struct_QmfProvidorReq_pack(QmfProvidorReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_QmfProvidorReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfProvidorReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_QmfProvidorReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfProvidorReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);


}



#endif
