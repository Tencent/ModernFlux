// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.0.0.31 by WSRD Tencent.
// Generated from `/usr/local/resin_system.mqq.com/webapps/communication/taf/upload/evanqi/qmf_protocal_define.jce'
// **********************************************************************

#include "qmf_protocal_define.h"

extern int pdu_header_pack1(pdu_protocol_header * pdu_header, uint8_t * pui_buff, uint32_t * pi_buff_len);
extern int pdu_header_pack2(uint8_t * pui_buff, uint32_t * pi_buff_len, uint32_t * pi_used_len);
extern int pdu_header_unpack(uint8_t * pui_buff, uint32_t * pi_buff_len, pdu_protocol_header * pdu_header, uint32_t * pi_end_len);

namespace QMF_PROTOCAL
{

    int struct_QmfClientIpInfo_pack(QmfClientIpInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_QmfClientIpInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, QmfClientIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_QmfClientIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfClientIpInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_QmfClientIpInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_QmfClientIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfClientIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_QmfClientIpInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_QmfTokenInfo_pack(QmfTokenInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_QmfTokenInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, QmfTokenInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_QmfTokenInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfTokenInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_QmfTokenInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_QmfTokenInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfTokenInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_QmfTokenInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_QmfAccInfo_pack(QmfAccInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_QmfAccInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, QmfAccInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_QmfAccInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfAccInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_QmfAccInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_QmfAccInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfAccInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_QmfAccInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_QmfBusiControl_pack(QmfBusiControl * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_QmfBusiControl_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, QmfBusiControl * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_QmfBusiControl_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfBusiControl * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_QmfBusiControl_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_QmfBusiControl_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfBusiControl * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_QmfBusiControl_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_mobile_get_config_req_pack(mobile_get_config_req * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_mobile_get_config_req_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, mobile_get_config_req * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_mobile_get_config_req_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, mobile_get_config_req * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_mobile_get_config_req_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_mobile_get_config_req_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, mobile_get_config_req * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_mobile_get_config_req_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_mobile_get_config_rsp_pack(mobile_get_config_rsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_mobile_get_config_rsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, mobile_get_config_rsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_mobile_get_config_rsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, mobile_get_config_rsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_mobile_get_config_rsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_mobile_get_config_rsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, mobile_get_config_rsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_mobile_get_config_rsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_RetryInfo_pack(RetryInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_RetryInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, RetryInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_RetryInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, RetryInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_RetryInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_RetryInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, RetryInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_RetryInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_QmfUpstream_pack(QmfUpstream * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_QmfUpstream_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, QmfUpstream * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_QmfUpstream_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfUpstream * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_QmfUpstream_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_QmfUpstream_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfUpstream * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_QmfUpstream_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_QmfDownstream_pack(QmfDownstream * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_QmfDownstream_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, QmfDownstream * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_QmfDownstream_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfDownstream * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_QmfDownstream_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_QmfDownstream_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfDownstream * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_QmfDownstream_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_ServiceOverLoad_pack(ServiceOverLoad * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_ServiceOverLoad_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, ServiceOverLoad * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_ServiceOverLoad_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ServiceOverLoad * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_ServiceOverLoad_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_ServiceOverLoad_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ServiceOverLoad * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_ServiceOverLoad_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCommonStringMap_pack(WnsCommonStringMap * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCommonStringMap_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCommonStringMap * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCommonStringMap_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCommonStringMap * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCommonStringMap_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCommonStringMap_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCommonStringMap * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCommonStringMap_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCommonBufferMap_pack(WnsCommonBufferMap * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCommonBufferMap_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCommonBufferMap * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCommonBufferMap_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCommonBufferMap * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCommonBufferMap_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCommonBufferMap_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCommonBufferMap * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCommonBufferMap_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_QmfProvidorReq_pack(QmfProvidorReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_QmfProvidorReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, QmfProvidorReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_QmfProvidorReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfProvidorReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_QmfProvidorReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_QmfProvidorReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, QmfProvidorReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_QmfProvidorReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


}

